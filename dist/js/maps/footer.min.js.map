{"version":3,"sources":["__a1-utilities.js","footer.min.js","__a0-polyfills.js"],"names":["windowWidth","jQuery","css","overflow","w","window","width","hasBeenScrolledPast","$element","elementTop","offset","top","screenTop","scrollTop","screenBottom","outerHeight","throttle","fn","threshold","scope","last","deferTimer","context","this","now","Date","args","arguments","clearTimeout","setTimeout","apply","debounce","func","wait","immediate","timeout","later","callNow","_typeof","Symbol","iterator","obj","constructor","prototype","global","factory","Promise","noop","bind","thisArg","handle","self","deferred","_state","_value","_deferreds","push","_handled","_immediateFn","cb","onFulfilled","onRejected","resolve","reject","promise","ret","e","newValue","TypeError","then","finale","doResolve","length","_unhandledRejectionFn","i","len","Handler","done","value","reason","ex","undefined","setTimeoutFunc","_proto","prom","all","arr","res","val","call","remaining","Array","slice","race","values","setImmediate","err","console","warn","isArray","arg","Object","toString","find","defineProperty","predicate","o","k","kValue","repaint","node","style","display","offsetHeight","randBetween","min","max","Math","floor","random"],"mappings":"AA4BA,QAASA,eAEPC,OAAO,QAAQC,KACbC,SAAU,UAIZ,IAAIC,GAAIH,OAAOI,QAAQC,OAOvB,OAJAL,QAAO,QAAQC,KACbC,SAAU,KAGLC,EAUT,QAASG,qBAAqBC,GAC5B,GAAIC,GAAaD,EAASE,SAASC,IAC/BC,EAAYX,OAAOI,QAAQQ,YAC3BC,EAAeF,EAAYX,OAAOI,QAAQU,aAE9C,OAAOD,IAAgBL,EAOzB,QAASO,UAASC,EAAIC,EAAWC,GAC/BD,EAAYA,GAAa,GACzB,IAAIE,GACAC,CACJ,OAAO,YACL,GAAIC,GAAUH,GAASI,KAEnBC,GAAO,GAAIC,MACXC,EAAOC,SACPP,IAAQI,EAAMJ,EAAOF,GAEvBU,aAAaP,GACbA,EAAaQ,WAAW,WACtBT,EAAOI,EACPP,EAAGa,MAAMR,EAASI,IACjBR,KAEHE,EAAOI,EACPP,EAAGa,MAAMR,EAASI,KAWxB,QAASK,UAASC,EAAMC,EAAMC,GAC5B,GAAIC,EACJ,OAAO,YACL,GAAIb,GAAUC,KAAMG,EAAOC,UACvBS,EAAQ,WACVD,EAAU,KACLD,GAAWF,EAAKF,MAAMR,EAASI,IAElCW,EAAUH,IAAcC,CAC5BP,cAAaO,GACbA,EAAUN,WAAWO,EAAOH,GACxBI,GAASL,EAAKF,MAAMR,EAASI,ICxGrC,GAAIY,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,eAAkBF,KCOnQ,SAAUG,EAAQC,GACZD,EAAOE,UACVF,EAAOE,QAAUD,MAEnBxC,OAAS,WAAc,YAMzB,SAAS0C,MAGT,QAASC,GAAK/B,EAAIgC,GAChB,MAAO,YACLhC,EAAGa,MAAMmB,EAAStB,YAItB,QAASuB,GAAOC,EAAMC,GACpB,KAAuB,IAAhBD,EAAKE,QACVF,EAAOA,EAAKG,MAEd,OAAoB,KAAhBH,EAAKE,WACPF,GAAKI,WAAWC,KAAKJ,IAGvBD,EAAKM,UAAW,MAChBX,GAAQY,aAAa,WACnB,GAAIC,GAAqB,IAAhBR,EAAKE,OAAeD,EAASQ,YAAcR,EAASS,UAC7D,IAAW,OAAPF,EAEF,YADiB,IAAhBR,EAAKE,OAAeS,EAAUC,GAAQX,EAASY,QAASb,EAAKG,OAGhE,IAAIW,EACJ,KACEA,EAAMN,EAAGR,EAAKG,QACd,MAAOY,GAEP,WADAH,GAAOX,EAASY,QAASE,GAG3BJ,EAAQV,EAASY,QAASC,MAI9B,QAASH,GAAQX,EAAMgB,GACrB,IAEE,GAAIA,IAAahB,EACf,KAAM,IAAIiB,WAAU,4CACtB,IACED,IACqB,YAApB,mBAAOA,GAAP,YAAA7B,QAAO6B,KAA6C,kBAAbA,IACxC,CACA,GAAIE,GAAOF,EAASE,IACpB,IAAIF,YAAoBrB,GAItB,MAHAK,GAAKE,OAAS,EACdF,EAAKG,OAASa,MACdG,GAAOnB,EAEF,IAAoB,kBAATkB,GAEhB,WADAE,GAAUvB,EAAKqB,EAAMF,GAAWhB,GAIpCA,EAAKE,OAAS,EACdF,EAAKG,OAASa,EACdG,EAAOnB,GACP,MAAOe,GACPH,EAAOZ,EAAMe,IAIjB,QAASH,GAAOZ,EAAMgB,GACpBhB,EAAKE,OAAS,EACdF,EAAKG,OAASa,EACdG,EAAOnB,GAGT,QAASmB,GAAOnB,GACM,IAAhBA,EAAKE,QAA2C,IAA3BF,EAAKI,WAAWiB,QACvC1B,EAAQY,aAAa,WACdP,EAAKM,UACRX,EAAQ2B,sBAAsBtB,EAAKG,SAKzC,KAAK,GAAIoB,GAAI,EAAGC,EAAMxB,EAAKI,WAAWiB,OAAQE,EAAIC,EAAKD,IACrDxB,EAAOC,EAAMA,EAAKI,WAAWmB,GAE/BvB,GAAKI,WAAa,KAGpB,QAASqB,GAAQhB,EAAaC,EAAYG,GACxCzC,KAAKqC,YAAqC,kBAAhBA,GAA6BA,EAAc,KACrErC,KAAKsC,WAAmC,kBAAfA,GAA4BA,EAAa,KAClEtC,KAAKyC,QAAUA,EASjB,QAASO,GAAUtD,EAAIkC,GACrB,GAAI0B,IAAO,CACX,KACE5D,EACE,SAAS6D,GACHD,IACJA,GAAO,EACPf,EAAQX,EAAM2B,KAEhB,SAASC,GACHF,IACJA,GAAO,EACPd,EAAOZ,EAAM4B,MAGjB,MAAOC,GACP,GAAIH,EAAM,MACVA,IAAO,EACPd,EAAOZ,EAAM6B,IAIjB,QAASlC,GAAQ7B,GACf,KAAMM,eAAgBuB,IACpB,KAAM,IAAIsB,WAAU,uCACtB,IAAkB,kBAAPnD,GAAmB,KAAM,IAAImD,WAAU,iBAClD7C,MAAK8B,OAAS,EACd9B,KAAKkC,UAAW,EAChBlC,KAAK+B,OAAS2B,OACd1D,KAAKgC,cAELgB,EAAUtD,EAAIM,MAjIhB,GAAI2D,GAAiBrD,WAoIjBsD,EAASrC,EAAQH,SA0FrB,OAzFAwC,GAAAA,SAAe,SAAStB,GACtB,MAAOtC,MAAK8C,KAAK,KAAMR,IAGzBsB,EAAOd,KAAO,SAAST,EAAaC,GAClC,GAAIuB,GAAO,GAAI7D,MAAKmB,YAAYK,EAGhC,OADAG,GAAO3B,KAAM,GAAIqD,GAAQhB,EAAaC,EAAYuB,IAC3CA,GAGTtC,EAAQuC,IAAM,SAASC,GACrB,MAAO,IAAIxC,GAAQ,SAASgB,EAASC,GAOnC,QAASwB,GAAIb,EAAGc,GACd,IACE,GAAIA,IAAuB,YAAf,mBAAOA,GAAP,YAAAlD,QAAOkD,KAAmC,kBAARA,IAAqB,CACjE,GAAInB,GAAOmB,EAAInB,IACf,IAAoB,kBAATA,GAQT,WAPAA,GAAKoB,KACHD,EACA,SAASA,GACPD,EAAIb,EAAGc,IAETzB,GAKNrC,EAAKgD,GAAKc,EACU,MAAdE,GACJ5B,EAAQpC,GAEV,MAAOsD,GACPjB,EAAOiB,IA1BX,IAAKM,GAA6B,mBAAfA,GAAId,OACrB,KAAM,IAAIJ,WAAU,+BACtB,IAAI1C,GAAOiE,MAAMhD,UAAUiD,MAAMH,KAAKH,EACtC,IAAoB,IAAhB5D,EAAK8C,OAAc,MAAOV,MA2B9B,KAAK,GA1BD4B,GAAYhE,EAAK8C,OA0BZE,EAAI,EAAGA,EAAIhD,EAAK8C,OAAQE,IAC/Ba,EAAIb,EAAGhD,EAAKgD,OAKlB5B,EAAQgB,QAAU,SAASgB,GACzB,MAAIA,IAA0B,YAAjB,mBAAOA,GAAP,YAAAxC,QAAOwC,KAAsBA,EAAMpC,cAAgBI,EACvDgC,EAGF,GAAIhC,GAAQ,SAASgB,GAC1BA,EAAQgB,MAIZhC,EAAQiB,OAAS,SAASe,GACxB,MAAO,IAAIhC,GAAQ,SAASgB,EAASC,GACnCA,EAAOe,MAIXhC,EAAQ+C,KAAO,SAASC,GACtB,MAAO,IAAIhD,GAAQ,SAASgB,EAASC,GACnC,IAAK,GAAIW,GAAI,EAAGC,EAAMmB,EAAOtB,OAAQE,EAAIC,EAAKD,IAC5CoB,EAAOpB,GAAGL,KAAKP,EAASC,MAM9BjB,EAAQY,aACmB,kBAAjBqC,eACN,SAAS9E,GACP8E,aAAa9E,KAEjB,SAASA,GACPiE,EAAejE,EAAI,IAGvB6B,EAAQ2B,sBAAwB,SAA+BuB,GACtC,mBAAZC,UAA2BA,SACpCA,QAAQC,KAAK,wCAAyCF,IAInDlD,IAMJ6C,MAAMQ,UACTR,MAAMQ,QAAU,SAASC,GACvB,MAA+C,mBAAxCC,OAAO1D,UAAU2D,SAASb,KAAKW,KAMrCT,MAAMhD,UAAU4D,MACnBF,OAAOG,eAAeb,MAAMhD,UAAW,QACrCmC,MAAO,SAAS2B,GAEd,GAAY,MAARlF,KACF,KAAM,IAAI6C,WAAU,gCAGtB,IAAIsC,GAAIL,OAAO9E,MAGXoD,EAAM+B,EAAElC,SAAW,CAGvB,IAAyB,kBAAdiC,GACT,KAAM,IAAIrC,WAAU,+BAUtB,KANA,GAAInB,GAAUtB,UAAU,GAGpBgF,EAAI,EAGDA,EAAIhC,GAAK,CAKd,GAAIiC,GAASF,EAAEC,EACf,IAAIF,EAAUhB,KAAKxC,EAAS2D,EAAQD,EAAGD,GACrC,MAAOE,EAGTD,QFrRR,IAAIE,SAAU,SAAEC,GACfA,EAAKC,MAAMC,QAAU,OACrBF,EAAKG,aACLH,EAAKC,MAAMC,QAAU,IASlBE,YAAc,SAAEC,EAAKC,GAAP,MAAgBC,MAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,IAAOA","file":"../footer.min.js","sourcesContent":["// Utility JavaScript functions\n// Comment-out switches are wrapped around each block\n// Use them to turn on/off specific utilities\n\n/**\n * Force a repaint of a specific DOM Node\n * @param  {DOMElement} node A native DOM element to repaint.\n *                           Not jQuery, use $element.get(0) to convert.\n */\nlet repaint = ( node ) => {\n node.style.display = 'none';\n node.offsetHeight; // jshint ignore:line\n node.style.display = '';\n};\n\n/**\n * Get a random integer between min and max.\n * @param  {Number} min The minimum integer to return.\n * @param  {Number} max The maximum integer to return.\n * @return {Number}\n */\nlet randBetween = ( min, max ) => Math.floor(Math.random() * (max - min + 1) ) + min;\n\n/**\n * Get the true window width, without scrollbars.\n * @return integer The window width in px.\n */\n//*\nfunction windowWidth() {\n  // Temporarily disable scrollbar\n  jQuery('body').css( {\n    overflow: 'hidden',\n  } );\n\n  // Get window width\n  var w = jQuery(window).width();\n\n  // Remove styles\n  jQuery('body').css( {\n    overflow: '',\n  } );\n\n  return w;\n}\n//*/\n\n/**\n * Check if an element has been scrolled past, \n * i.e. it is on screen or above the viewport.\n * @param  {jQuery}  $element The element to check.\n * @return {Boolean}          \n */\nfunction hasBeenScrolledPast( $element ) {\n  var elementTop = $element.offset().top,\n      screenTop = jQuery(window).scrollTop(),\n      screenBottom = screenTop + jQuery(window).outerHeight();\n\n  return screenBottom >= elementTop;\n}\n\n/**\n * Returns a function that will be called at most every N milliseconds.\n */\n//*\nfunction throttle(fn, threshold, scope) {\n  threshold = threshold || 250;\n  var last,\n      deferTimer;\n  return function () {\n    var context = scope || this;\n\n    var now = +new Date(),\n        args = arguments;\n    if (last && now < last + threshold) {\n      // hold on to it\n      clearTimeout(deferTimer);\n      deferTimer = setTimeout(function () {\n        last = now;\n        fn.apply(context, args);\n      }, threshold);\n    } else {\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}\n//*/\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n//*\nfunction debounce(func, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n//*/\n","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// Polyfills\n\n/**\n * Promise polyfill\n * @see https://github.com/taylorhakes/promise-polyfill\n */\n// Promise Collapsible Group\n(function (global, factory) {\n  if (!global.Promise) {\n    global.Promise = factory();\n  }\n})(window, function () {\n  'use strict';\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n\n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function () {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  function Promise(fn) {\n    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  var _proto = Promise.prototype;\n  _proto.catch = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  _proto.then = function (onFulfilled, onRejected) {\n    var prom = new this.constructor(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function (arr) {\n    return new Promise(function (resolve, reject) {\n      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');\n      var args = Array.prototype.slice.call(arr);\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {\n    setImmediate(fn);\n  } || function (fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  return Promise;\n});\n// /Promise Collapsible Group\n\n//*\nif (!Array.isArray) {\n  Array.isArray = function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n//*/\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.find\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function value(predicate) {\n      // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return kValue.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return undefined.\n      return undefined;\n    }\n  });\n}\n// Utility JavaScript functions\n// Comment-out switches are wrapped around each block\n// Use them to turn on/off specific utilities\n\n/**\n * Force a repaint of a specific DOM Node\n * @param  {DOMElement} node A native DOM element to repaint.\n *                           Not jQuery, use $element.get(0) to convert.\n */\nvar repaint = function repaint(node) {\n  node.style.display = 'none';\n  node.offsetHeight; // jshint ignore:line\n  node.style.display = '';\n};\n\n/**\n * Get a random integer between min and max.\n * @param  {Number} min The minimum integer to return.\n * @param  {Number} max The maximum integer to return.\n * @return {Number}\n */\nvar randBetween = function randBetween(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Get the true window width, without scrollbars.\n * @return integer The window width in px.\n */\n//*\nfunction windowWidth() {\n  // Temporarily disable scrollbar\n  jQuery('body').css({\n    overflow: 'hidden'\n  });\n\n  // Get window width\n  var w = jQuery(window).width();\n\n  // Remove styles\n  jQuery('body').css({\n    overflow: ''\n  });\n\n  return w;\n}\n//*/\n\n/**\n * Check if an element has been scrolled past, \n * i.e. it is on screen or above the viewport.\n * @param  {jQuery}  $element The element to check.\n * @return {Boolean}          \n */\nfunction hasBeenScrolledPast($element) {\n  var elementTop = $element.offset().top,\n      screenTop = jQuery(window).scrollTop(),\n      screenBottom = screenTop + jQuery(window).outerHeight();\n\n  return screenBottom >= elementTop;\n}\n\n/**\n * Returns a function that will be called at most every N milliseconds.\n */\n//*\nfunction throttle(fn, threshold, scope) {\n  threshold = threshold || 250;\n  var last, deferTimer;\n  return function () {\n    var context = scope || this;\n\n    var now = +new Date(),\n        args = arguments;\n    if (last && now < last + threshold) {\n      // hold on to it\n      clearTimeout(deferTimer);\n      deferTimer = setTimeout(function () {\n        last = now;\n        fn.apply(context, args);\n      }, threshold);\n    } else {\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}\n//*/\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n//*\nfunction debounce(func, wait, immediate) {\n  var timeout;\n  return function () {\n    var context = this,\n        args = arguments;\n    var later = function later() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n//*/","// Polyfills\n\n/**\n * Promise polyfill\n * @see https://github.com/taylorhakes/promise-polyfill\n */\n// Promise Collapsible Group\n  (function (global, factory) {\n    if (!global.Promise) {\n      global.Promise = factory();\n    }\n  }(window, (function () { 'use strict';\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n\n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function() {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function() {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self)\n        throw new TypeError('A promise cannot be resolved with itself.');\n      if (\n        newValue &&\n        (typeof newValue === 'object' || typeof newValue === 'function')\n      ) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function() {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(\n        function(value) {\n          if (done) return;\n          done = true;\n          resolve(self, value);\n        },\n        function(reason) {\n          if (done) return;\n          done = true;\n          reject(self, reason);\n        }\n      );\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  function Promise(fn) {\n    if (!(this instanceof Promise))\n      throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  var _proto = Promise.prototype;\n  _proto.catch = function(onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  _proto.then = function(onFulfilled, onRejected) {\n    var prom = new this.constructor(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function(arr) {\n    return new Promise(function(resolve, reject) {\n      if (!arr || typeof arr.length === 'undefined')\n        throw new TypeError('Promise.all accepts an array');\n      var args = Array.prototype.slice.call(arr);\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(\n                val,\n                function(val) {\n                  res(i, val);\n                },\n                reject\n              );\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function(value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function(resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function(value) {\n    return new Promise(function(resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function(values) {\n    return new Promise(function(resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn =\n    (typeof setImmediate === 'function' &&\n      function(fn) {\n        setImmediate(fn);\n      }) ||\n    function(fn) {\n      setTimeoutFunc(fn, 0);\n    };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  return Promise;\n\n  })));\n// /Promise Collapsible Group\n\n//*\nif (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n//*/\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.find\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n     // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return kValue.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return undefined.\n      return undefined;\n    }\n  });\n}\n"]}